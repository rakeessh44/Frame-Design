<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Frame Store Preview</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fabric.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        #previewCanvas {
            border: 2px solid #e0e0e0;
            background-color: #ffffff;
            border-radius: 1rem; /* Rounded corners for the canvas */
        }
        /* Custom scrollbar for frame selection */
        .overflow-x-auto::-webkit-scrollbar {
            height: 8px;
        }
        .overflow-x-auto::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Styles for sticker buttons */
        .sticker-btn {
            @apply flex-shrink-0 w-16 h-16 sm:w-20 sm:h-20 flex items-center justify-center bg-gray-100 rounded-lg shadow-md cursor-pointer transition-all duration-200 ease-in-out hover:shadow-lg hover:bg-gray-200;
        }
        .sticker-btn img, .sticker-btn .emoji {
            @apply w-10 h-10 sm:w-12 sm:h-12 object-contain;
        }
        .sticker-btn .emoji {
             font-size: 3rem; /* Adjust emoji size */
        }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8 flex flex-col items-center min-h-screen">

    <div class="max-w-4xl w-full bg-white shadow-xl rounded-2xl p-6 sm:p-8 md:p-10 mb-8">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center text-gray-800 mb-6">
            Design Your Perfect Photo Frame
        </h1>
        <p class="text-lg text-center text-gray-600 mb-8">
            Upload your image, choose a frame design, drag and resize, add text, and fun stickers!
        </p>

        <!-- Image Upload Section -->
        <div class="mb-8 p-6 bg-blue-50 rounded-xl shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
            <label for="imageUpload" class="cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
                <span class="flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    Upload Your Image
                </span>
            </label>
            <input type="file" id="imageUpload" accept="image/*" class="hidden">
            <span id="fileName" class="text-gray-700 text-base italic">No image selected</span>
        </div>

        <!-- Frame Selection Section -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Choose a Frame Design</h2>
            <div id="frameSelection" class="flex flex-nowrap overflow-x-auto gap-4 pb-4">
                <!-- Frame options will be loaded here by JavaScript -->
            </div>
        </div>

        <!-- Custom Text Section -->
        <div class="mb-8 p-6 bg-purple-50 rounded-xl shadow-inner">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Add Custom Text</h2>
            <div class="flex flex-col sm:flex-row gap-4 items-center mb-4">
                <input type="text" id="customTextInput" placeholder="Your text here..." class="flex-grow p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-200">
                <select id="fontFamilySelect" class="p-3 border border-gray-300 rounded-md bg-white focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-200">
                    <option value="Arial">Arial</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Impact">Impact</option>
                </select>
                <input type="number" id="fontSizeInput" value="40" min="10" max="100" class="w-20 p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-200">
                <input type="color" id="fontColorInput" value="#000000" class="w-10 h-10 border border-gray-300 rounded-md cursor-pointer">
            </div>
            <div class="flex justify-center">
                <button id="addTextButton" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-300">
                    Add Text to Frame
                </button>
            </div>
        </div>

        <!-- Stickers Section -->
        <div class="mb-8 p-6 bg-pink-50 rounded-xl shadow-inner">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Add Fun Stickers</h2>
            <div id="stickerSelection" class="flex flex-wrap justify-center gap-3 sm:gap-4">
                <!-- Stickers will be loaded here by JavaScript -->
            </div>
        </div>

        <!-- Canvas Preview Area -->
        <div class="flex justify-center items-center mb-8 bg-gray-100 p-4 rounded-xl shadow-md">
            <canvas id="previewCanvas" width="600" height="450" class="max-w-full h-auto"></canvas>
        </div>

        <!-- Delete Button for Text/Stickers -->
        <div class="flex justify-center">
            <button id="deleteSelectedButton" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-8 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-300">
                <span class="flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    Delete Selected Object
                </span>
            </button>
        </div>
    </div>

    <script>
        // Initialize Fabric.js canvas
        const canvas = new fabric.Canvas('previewCanvas');
        let uploadedImage = null; // To store the user's uploaded image
        let currentFrame = null;  // To store the currently selected frame
        let currentFrameData = null; // To store data of the current frame (cutout info)
        let clipRect = null; // The clipping rectangle for the image
        let innerBorderRect = null; // Rectangle for the inner border

        // Define pre-built frame designs and their cutout areas (relative percentages)
        const frameDesigns = [
            {
                id: 'frame1',
                name: 'Classic Wood',
                imageUrl: 'https://placehold.co/250x200/a0522d/ffffff?text=Classic+Wood+Frame',
                // Cutout: x, y, width, height as percentages of the frame image dimensions
                cutout: { x: 0.15, y: 0.15, width: 0.70, height: 0.70 },
                aspectRatio: 250 / 200 // Original aspect ratio for placeholder
            },
            {
                id: 'frame2',
                name: 'Modern Black',
                imageUrl: 'https://placehold.co/250x200/333333/ffffff?text=Modern+Black+Frame',
                cutout: { x: 0.10, y: 0.10, width: 0.80, height: 0.80 },
                aspectRatio: 250 / 200
            },
            {
                id: 'frame3',
                name: 'Elegant Gold',
                imageUrl: 'https://placehold.co/250x200/daa520/ffffff?text=Elegant+Gold+Frame',
                cutout: { x: 0.18, y: 0.18, width: 0.64, height: 0.64 },
                aspectRatio: 250 / 200
            },
            {
                id: 'frame4',
                name: 'Minimal White',
                imageUrl: 'https://placehold.co/250x200/ffffff/000000?text=Minimal+White+Frame',
                cutout: { x: 0.05, y: 0.05, width: 0.90, height: 0.90 },
                aspectRatio: 250 / 200
            },
            {
                id: 'frame5',
                name: 'Rustic Brown',
                imageUrl: 'https://placehold.co/250x200/8B4513/ffffff?text=Rustic+Brown+Frame',
                cutout: { x: 0.12, y: 0.12, width: 0.76, height: 0.76 },
                aspectRatio: 250 / 200
            },
            {
                id: 'frame6',
                name: 'Silver Slim',
                imageUrl: 'https://placehold.co/250x200/C0C0C0/000000?text=Silver+Slim+Frame',
                cutout: { x: 0.08, y: 0.08, width: 0.84, height: 0.84 },
                aspectRatio: 250 / 200
            },
            {
                id: 'frame7',
                name: 'Square 2x2',
                // Using 200x200 for a square aspect ratio representative of 2x2
                imageUrl: 'https://placehold.co/200x200/FF5733/ffffff?text=2x2+Frame',
                cutout: { x: 0.10, y: 0.10, width: 0.80, height: 0.80 },
                aspectRatio: 1 // 1:1 aspect ratio
            },
            {
                id: 'frame8',
                name: 'Square 4x4',
                // Using 200x200 for a square aspect ratio representative of 4x4
                imageUrl: 'https://placehold.co/200x200/33FF57/000000?text=4x4+Frame',
                cutout: { x: 0.08, y: 0.08, width: 0.84, height: 0.84 },
                aspectRatio: 1 // 1:1 aspect ratio
            },
            {
                id: 'frame9',
                name: 'A4 Size',
                // A4 aspect ratio is approximately 1:1.414 (210mm x 297mm)
                imageUrl: 'https://placehold.co/200x283/000000/ffffff?text=A4+Frame',
                cutout: { x: 0.07, y: 0.07, width: 0.86, height: 0.86 },
                aspectRatio: 210 / 297 // A4 aspect ratio
            }
        ];

        // Digital stickers data (using emojis for simplicity)
        const stickers = [
            { id: 'heart', emoji: '❤️' },
            { id: 'star', emoji: '⭐' },
            { id: 'flower', emoji: '🌸' },
            { id: 'smiley', emoji: '😊' },
            { id: 'paw', emoji: '🐾' },
            { id: 'camera', emoji: '📸' }
        ];

        // Function to render frames in the selection area
        function renderFrameSelection() {
            const frameSelectionDiv = document.getElementById('frameSelection');
            frameSelectionDiv.innerHTML = ''; // Clear previous frames

            frameDesigns.forEach(frame => {
                const frameCard = document.createElement('div');
                frameCard.className = 'flex-shrink-0 w-32 cursor-pointer p-2 rounded-xl transition-all duration-200 ease-in-out hover:shadow-lg hover:border-blue-500 border-2 border-transparent bg-gray-50';
                frameCard.setAttribute('data-frame-id', frame.id);

                const img = document.createElement('img');
                img.src = frame.imageUrl;
                img.alt = frame.name;
                // Adjust thumbnail height based on aspect ratio for better representation
                let thumbHeight = 96; // default h-24 = 96px
                if (frame.aspectRatio) {
                    thumbHeight = 128 / frame.aspectRatio; // Fixed width of 128px for thumbnail, adjust height
                }
                img.style.width = '100%';
                img.style.height = `${thumbHeight}px`;
                img.style.objectFit = 'contain'; // Use contain to show full frame
                img.className += ' rounded-md mb-2 shadow-sm';

                const name = document.createElement('p');
                name.textContent = frame.name;
                name.className = 'text-center text-sm font-medium text-gray-700';

                frameCard.appendChild(img);
                frameCard.appendChild(name);
                frameSelectionDiv.appendChild(frameCard);

                frameCard.addEventListener('click', () => selectFrame(frame.id));
            });
        }

        // Function to render stickers in the selection area
        function renderStickerSelection() {
            const stickerSelectionDiv = document.getElementById('stickerSelection');
            stickerSelectionDiv.innerHTML = ''; // Clear previous stickers

            stickers.forEach(sticker => {
                const stickerButton = document.createElement('button');
                stickerButton.className = 'sticker-btn'; // Apply Tailwind classes from style block
                stickerButton.setAttribute('data-sticker-id', sticker.id);
                stickerButton.innerHTML = `<span class="emoji">${sticker.emoji}</span>`; // Using emoji directly

                stickerSelectionDiv.appendChild(stickerButton);

                stickerButton.addEventListener('click', () => addStickerToCanvas(sticker.emoji));
            });
        }


        // Function to update the canvas with the selected frame and uploaded image
        function updatePreview() {
            // Remove previous frame, inner border, and clipRect if they exist
            if (currentFrame && canvas.contains(currentFrame)) {
                canvas.remove(currentFrame);
            }
            if (innerBorderRect && canvas.contains(innerBorderRect)) {
                canvas.remove(innerBorderRect);
            }
            // ClipRect is a property of the image, not a standalone canvas object
            if (uploadedImage) {
                uploadedImage.clipPath = undefined; // Remove old clipPath reference
            }

            // Set background for canvas if needed (e.g., if frame doesn't cover entire canvas)
            canvas.backgroundColor = '#ffffff'; // Default white background

            if (currentFrame) {
                // Adjust the size and position of the frame to fit the canvas
                const canvasWidth = canvas.getWidth();
                const canvasHeight = canvas.getHeight();

                let frameScaleFactor;
                const frameAspectRatio = currentFrame.width / currentFrame.height;
                if (frameAspectRatio > canvasWidth / canvasHeight) { // Frame is wider relative to canvas
                    frameScaleFactor = canvasWidth / currentFrame.width;
                } else { // Frame is taller relative to canvas
                    frameScaleFactor = canvasHeight / currentFrame.height;
                }

                currentFrame.set({
                    scaleX: frameScaleFactor,
                    scaleY: frameScaleFactor,
                    left: (canvasWidth - currentFrame.width * frameScaleFactor) / 2,
                    top: (canvasHeight - currentFrame.height * frameScaleFactor) / 2,
                    selectable: false, // Make frame not selectable
                    evented: false, // Make frame not clickable
                });
                canvas.add(currentFrame); // Add the frame to the canvas
                currentFrame.sendToBack(); // Ensure frame is the very back object
            }

            if (currentFrameData) {
                 // Calculate dynamic cutout dimensions based on the current frame position and scale
                const scaledCutoutX = currentFrame.left + (currentFrameData.cutout.x * currentFrame.getScaledWidth());
                const scaledCutoutY = currentFrame.top + (currentFrameData.cutout.y * currentFrame.getScaledHeight());
                const scaledCutoutWidth = currentFrameData.cutout.width * currentFrame.getScaledWidth();
                const scaledCutoutHeight = currentFrameData.cutout.height * currentFrame.getScaledHeight();

                // Define the clipping path (the "window" of the frame)
                clipRect = new fabric.Rect({
                    left: scaledCutoutX,
                    top: scaledCutoutY,
                    width: scaledCutoutWidth,
                    height: scaledCutoutHeight,
                    absolutePositioned: true, // Crucial: Clip path positions itself absolutely on canvas
                    // These properties make it invisible on the canvas but it still functions as a clipPath
                    fill: 'transparent',
                    stroke: 'transparent',
                    selectable: false,
                    evented: false
                });

                // Add the inner border rectangle
                innerBorderRect = new fabric.Rect({
                    left: scaledCutoutX,
                    top: scaledCutoutY,
                    width: scaledCutoutWidth,
                    height: scaledCutoutHeight,
                    stroke: '#000000', // Black border
                    strokeWidth: 2,    // Thin border
                    fill: 'transparent',
                    selectable: false,
                    evented: false,
                    absolutePositioned: true // Position based on canvas coordinates
                });
                canvas.add(innerBorderRect); // Add the inner border rectangle
                innerBorderRect.bringToFront(); // Bring inner border to front of frame and image
            }


            if (uploadedImage && currentFrameData) {
                // Attach the clipPath to the uploaded image
                uploadedImage.clipPath = clipRect;

                const scaledCutoutX = clipRect.left;
                const scaledCutoutY = clipRect.top;
                const scaledCutoutWidth = clipRect.width;
                const scaledCutoutHeight = clipRect.height;

                const imageAspectRatio = uploadedImage.width / uploadedImage.height;
                const cutoutAspectRatio = scaledCutoutWidth / scaledCutoutHeight;

                let imgScaleX, imgScaleY;

                if (imageAspectRatio > cutoutAspectRatio) {
                    imgScaleY = scaledCutoutHeight / uploadedImage.height;
                    imgScaleX = imgScaleY;
                } else {
                    imgScaleX = scaledCutoutWidth / uploadedImage.width;
                    imgScaleY = imgScaleX;
                }

                uploadedImage.set({
                    scaleX: imgScaleX,
                    scaleY: imgScaleY,
                    // Always center the image within the cutout after scaling
                    left: scaledCutoutX + (scaledCutoutWidth - uploadedImage.getScaledWidth()) / 2,
                    top: scaledCutoutY + (scaledCutoutHeight - uploadedImage.getScaledHeight()) / 2,
                    selectable: true,
                    evented: true,
                    hasControls: true,
                    hasBorders: true,
                });

                if (!canvas.contains(uploadedImage)) {
                    canvas.add(uploadedImage); // Add the image if not already on canvas
                }
                // Ensure image is above the frame but below the inner border, text, and stickers
                uploadedImage.sendBackwards(); // Send just one layer back
            }

            canvas.renderAll(); // Re-render the canvas to show changes
        }

        // Handle frame selection
        function selectFrame(frameId) {
            const selectedFrameData = frameDesigns.find(f => f.id === frameId);
            if (!selectedFrameData) return;

            // Remove previous active class
            document.querySelectorAll('#frameSelection > div').forEach(card => {
                card.classList.remove('border-blue-500', 'shadow-lg');
            });

            // Add active class to the newly selected frame
            const newActiveCard = document.querySelector(`[data-frame-id="${frameId}"]`);
            if (newActiveCard) {
                newActiveCard.classList.add('border-blue-500', 'shadow-lg');
            }

            // Load the frame image onto the canvas
            fabric.Image.fromURL(selectedFrameData.imageUrl, function(oImg) {
                currentFrame = oImg;
                currentFrameData = selectedFrameData;
                updatePreview();
            }, {
                crossOrigin: 'anonymous' // Important for loading images from external domains
            });
        }

        // Handle image upload
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const fileNameSpan = document.getElementById('fileName');

            if (file) {
                fileNameSpan.textContent = file.name;
                const reader = new FileReader();
                reader.onload = function(event) {
                    fabric.Image.fromURL(event.target.result, function(oImg) {
                        uploadedImage = oImg;
                        // No need for initialCentered flag anymore, centering is unconditional
                        updatePreview();
                    });
                };
                reader.readAsDataURL(file);
            } else {
                fileNameSpan.textContent = 'No image selected';
                if (uploadedImage) {
                    canvas.remove(uploadedImage); // Remove image from canvas
                    uploadedImage = null; // Clear uploaded image
                }
                updatePreview(); // Update canvas to reflect no image
            }
        });

        // Function to add custom text to canvas
        document.getElementById('addTextButton').addEventListener('click', function() {
            const textContent = document.getElementById('customTextInput').value.trim();
            if (textContent === '') {
                showMessageBox('Please enter some text to add.');
                return;
            }

            const fontFamily = document.getElementById('fontFamilySelect').value;
            const fontSize = parseInt(document.getElementById('fontSizeInput').value);
            const fontColor = document.getElementById('fontColorInput').value;

            const newText = new fabric.IText(textContent, {
                left: canvas.getWidth() / 2, // Initial position, roughly centered
                top: canvas.getHeight() / 2,
                fontFamily: fontFamily,
                fontSize: fontSize,
                fill: fontColor,
                hasControls: true, // Allow resizing and rotating
                hasBorders: true,
                originX: 'center',
                originY: 'center',
            });

            canvas.add(newText);
            canvas.setActiveObject(newText); // Select the new text object
            newText.bringToFront(); // Ensure text is always on top
            canvas.renderAll();
        });


        // Function to add sticker to canvas
        function addStickerToCanvas(emoji) {
            const stickerText = new fabric.Text(emoji, {
                left: canvas.getWidth() / 2,
                top: canvas.getHeight() / 2,
                fontSize: 60, // Initial size for emoji stickers
                originX: 'center',
                originY: 'center',
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
            });
            canvas.add(stickerText);
            canvas.setActiveObject(stickerText); // Select the new sticker object
            stickerText.bringToFront(); // Ensure sticker is always on top
            canvas.renderAll();
        }

        // Handle delete selected object
        document.getElementById('deleteSelectedButton').addEventListener('click', function() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                // Prevent deleting the frame, inner border, or the main uploaded image unintentionally
                if (activeObject === currentFrame || activeObject === innerBorderRect || activeObject === uploadedImage) {
                    showMessageBox('You cannot delete the frame or the main uploaded image. Only custom text and stickers can be deleted.');
                    return;
                }
                canvas.remove(activeObject);
                canvas.discardActiveObject(); // Deselect the object after removal
                canvas.renderAll();
            } else {
                showMessageBox('No object selected to delete. Please select text or a sticker first.');
            }
        });

        // Simple Message Box Implementation (replaces alert())
        function showMessageBox(message) {
            let messageBox = document.getElementById('messageBox');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'messageBox';
                messageBox.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 transition-opacity duration-300 opacity-0';
                messageBox.innerHTML = `
                    <div class="bg-white p-8 rounded-xl shadow-2xl text-center max-w-sm w-full transform -translate-y-4 transition-transform duration-300">
                        <p class="text-xl font-semibold text-gray-800 mb-6">${message}</p>
                        <button id="closeMessageBox" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-300 ease-in-out">OK</button>
                    </div>
                `;
                document.body.appendChild(messageBox);

                document.getElementById('closeMessageBox').addEventListener('click', () => {
                    messageBox.classList.remove('opacity-100');
                    messageBox.classList.add('opacity-0');
                    setTimeout(() => messageBox.remove(), 300); // Remove after transition
                });

                // Allow clicking outside to close
                messageBox.addEventListener('click', (e) => {
                    if (e.target === messageBox) {
                        messageBox.classList.remove('opacity-100');
                        messageBox.classList.add('opacity-0');
                        setTimeout(() => messageBox.remove(), 300);
                    }
                });
            } else {
                 messageBox.querySelector('p').textContent = message;
            }
            messageBox.classList.remove('opacity-0');
            messageBox.classList.add('opacity-100');
             messageBox.querySelector('div').classList.remove('-translate-y-4');
            messageBox.querySelector('div').classList.add('translate-y-0');
        }


        // Initialize frame selection and sticker selection on page load
        window.onload = function() {
            renderFrameSelection();
            renderStickerSelection();
            // Select the first frame by default
            if (frameDesigns.length > 0) {
                selectFrame(frameDesigns[0].id);
            }
        };

        // Make canvas responsive by adjusting its dimensions on window resize
        function resizeCanvas() {
            const container = document.querySelector('.bg-gray-100'); // Get the container of the canvas
            // Use a factor of container width to set canvas width, capped at 600px
            const newWidth = Math.min(600, container.clientWidth * 0.95);
            // Maintain original aspect ratio (600x450)
            const newHeight = (newWidth / 600) * 450;

            canvas.setDimensions({ width: newWidth, height: newHeight });

            // Re-render and update positions of objects after canvas resize
            // The clipPath and innerBorderRect will be recreated based on the new frame size
            updatePreview();

            canvas.renderAll();
        }

        window.addEventListener('resize', resizeCanvas);
        // Initial canvas resize on load
        resizeCanvas();

    </script>
</body>
</html>
